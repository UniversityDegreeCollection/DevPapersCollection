# Recovery Oriented Programming
                               (Extended Abstract)

                            Olga Brukman, Shlomi Dolev

Department of Computer Science, Ben-Gurion University of the Negev, Beer-Sheva,
                 84105, Israel brukman,dolev@cs.bgu.ac.il

## Resumo.

Escrever um código perfeitamente correto é uma tarefa desafiadora e quase impossível. Neste trabalho, sugerimos o paradigma de programação orientada à recuperação, a fim de lidar com eventuais programas bizantinos.
O compositor de especificação do programa aplica as especificações do programa (propriedades de segurança e liberdade) em tempo de execução usando predicados sobre variáveis ​​de entrada e saída. O programador de componentes usará essas variáveis ​​na implementação do programa. Sugerimos o uso da abordagem de "caixa de areia", na qual todas as instruções do programa que alteram uma variável de especificação são executadas primeiro com variáveis ​​temporárias e são para evitar a execução de uma instrução que viola as especificações. Além disso, o monitoramento externo é usado para lidar com falhas transitórias e para garantir a convergência para um estado legal.

A implementação dessas idéias inclui a definição de novas instruções na linguagem de programação com o objetivo de permitir a adição de predicados e ações de recuperação. Sugerimos um design para uma ferramenta que estende a linguagem de programação Java. Além disso, fornecemos um esquema de prova de correção para provar que o código combinado com os predicados e as ações de recuperação é autoestabilizável e, sob a premissa de reinicialização, eventualmente cumpre suas especificações.

Palavras-chave: auto-estabilização, computação autonômica.

## 1. Introdução

Escrever um código perfeitamente correto é uma tarefa desafiadora e quase impossível. Paradigmas, ferramentas e ambientes de programação, incluindo programação estruturada, programação orientada a objetos, padrões de design e outros, foram criados para ajudar o programador a escrever um código gerenciável e correto. Ferramentas que garantem testes durante a fase de programação complementam o esforço acima [2, 5, 13]. Ainda assim, em muitos casos, as especificações do programa não são cumpridas [19] - uma situação que pode causar muitos danos. Em nosso trabalho anterior sobre recuperador autonômico estabilizador [4], sugerimos um framework formal para o paradigma orientado à recuperação [20]. A abordagem sugerida ajustou os pacotes de software existentes (caixa preta), que resultaram em uma sobrecarga alta, pois cada ação de E/S tinha que ser interceptada para detectar um estado defeituoso.

>Parcialmente apoiado pelo Centro de Ciências da Computação Lynn e William Frankel, pela concessão da Deutsche Telecom, pelo prêmio da faculdade IBM, pelo Ministério da Ciência de Israel e pela Cadeira Rita Altura Trust em Ciências da Computação.

>Olga Brukman e Shlomi Dolev

Paradigmas de tolerância a falhas e eventual software bizantino. A autoestabilização [9] é uma forte propriedade de tolerância a falhas para sistemas que garante a recuperação automática quando as falhas param de ocorrer. Um sistema autoestabilizante é capaz de iniciar a partir de qualquer configuração possível em que processadores, processos, links de comunicação, buffers de comunicação e quaisquer outros componentes relacionados ao processo estejam em um estado arbitrário (por exemplo, valores de variáveis ​​arbitrários, contador de programa arbitrário). O designer pode apenas assumir que os programas do sistema são executados. Com base nessa premissa, ele ou ela prova que o sistema converge para um estado legal, ou seja, para um estado em que o sistema satisfaz suas especificações. Se o sistema for iniciado a partir de um estado inicial legal, a execução garantirá que o sistema permaneça em um estado legal. Isso é chamado de "propriedade de fechamento". Caso o sistema seja iniciado em um estado ilegal (possivelmente após encontrar falhas transitórias), a execução do programa de autoestabilização garantirá que, eventualmente (em um número finito de etapas), um estado legal seja alcançado. Isso é chamado de "propriedade de convergência". Novamente, quando o programa atingir um estado legal, ele continuará em execução e permanecerá em um estado legal até que uma falha (transitória) ocorra novamente. Um algoritmo autoestabilizador nunca termina. O algoritmo não precisa necessariamente “identificar” a ocorrência da falha e se recuperar, mas continua sendo executado e traz o sistema para um estado legal. A complexidade de tempo de um algoritmo auto-estabilizador é o número de etapas necessárias para que um algoritmo iniciado em um estado arbitrário converja para um estado legal. Observe que quando todos os processadores executam programas incorretos (programas com bugs), eles podem exibir qualquer tipo de comportamento e, portanto, não há garantia de convergência.

O modelo de falha bizantina [16, 10] é usado para modelar o comportamento arbitrário (de fato, malicioso) de um programa que contém bugs e, portanto, não obedece às especificações. Os sistemas que toleram um número limitado de processadores bizantinos (normalmente, menos de um terço dos processadores podem ser bizantinos) foram projetados e provaram estar corretos.

A pesquisa em sistemas auto-estabilizantes e sistemas que modelam falhas através do comportamento bizantino ainda não forneceu soluções para sistemas nos quais os pacotes de software contêm bugs com uma probabilidade muito alta. Observamos que os pacotes de software geralmente funcionam conforme necessário por um longo período de tempo após serem iniciados a partir de um estado inicial. O comportamento correto inicial pode ser atribuído aos testes realizados pelo fabricante do software. Portanto, os programas iniciados a partir de um estado inicial são executados corretamente para execuções de tamanho limitado. Os administradores e usuários do sistema ocasionalmente reiniciam esse software para lidar com falhas. Nossa contribuição. Nosso objetivo é incorporar os predicados do programa e as ações de recuperação fornecidas pelo compositor de especificação do programa com o código do programa, para que a violação dos predicados seja detectada e evitada durante o tempo de execução. Tanto os predicados quanto as ações de recuperação serão parte integrante da especificação do programa. Nesse escopo, estamos interessados ​​em um novo paradigma de programação que complementa o caso de pacotes de software de caixa preta (abordados em [4]).

Essa abordagem altera a responsabilidade do compositor de especificação do programa (por exemplo, gerente de projeto). Além de fornecer especificações formais completas, o compositor deve declarar propriedades críticas de segurança e vivacidade e fornecer ações de recuperação para cada propriedade (pode haver algumas ações de recuperação para cada propriedade). As ações de recuperação serão executadas se o predicado for violado. O programador fará o possível para escrever um programa que atenda a essas especificações. Ainda assim, o programa pode encontrar alguns estados imprevisíveis devido a erros ou falhas transitórias. Nossa estrutura gera automaticamente código adicional para o programa. Este código aplicará o comportamento satisfatório do programa (assumindo a propriedade de capacidade de reinicialização dos programas [20]), verificando os predicados fornecidos pelo compositor de especificação do programa durante o tempo de execução e executando ações de recuperação, por exemplo, reinicie, no caso de falhas de predicados.

A execução de uma instrução que viole as especificações deve ser evitada. Sugerimos o uso da "caixa de areia": todas as instruções do programa que alteram uma variável de especificação serão executadas primeiro em variáveis temporárias. Caso os predicados não sejam violados em relação às variáveis temporárias, a instrução é executada. Caso contrário, a execução desta instrução será interrompida e uma ação de recuperação ocorrerá.

Um programa pode estar em um estado ilegal (possivelmente loop infinito), executando partes nas quais nenhuma variável predicada é atualizada. Portanto, as especificações podem não ser verificadas, possivelmente nunca. Nesses casos, é necessário um monitoramento externo para lidar com falhas transitórias e garantir a convergência para um estado legal. O monitor externo verificará as especificações periodicamente e aplicará um estado em que as especificações se mantêm.

Sugerimos um design para uma ferramenta genérica que estenda uma linguagem orientada a objetos, por exemplo, a linguagem de programação Java. O pré-compilador foi projetado para suportar novas primitivas para a programação orientada à recuperação. Além disso, fornecemos um esquema de prova de correção para provar que, sob a suposição de execução rsf (Definição 1), o código combinado com os predicados e as ações de recuperação atende às suas especificações.

Nosso framework é o primeira, com o melhor de nosso conhecimento, a garantir a validade eventual das especificações, iniciando em qualquer estado inicial. Isso é obtido com base na plataforma de software autoestabilizável, usando sandbox e monitoração externa. Abordamos o monitoramento completo das propriedades de vivacidade, enquanto outros trabalhos consideram apenas propriedades de segurança.

Enquanto especificações completas definem de fato um programa [22], consideramos especificações abstratas de tarefas, que deixam liberdade para o programador escolher a maneira (eficiente) de escrever o programa, incluindo estruturas de dados e algoritmos específicos. As especificações abstratas da tarefa refletem a funcionalidade mínima desejada do sistema.

A estrutura sugerida é capaz de lidar com falhas transitórias. Além disso, assumimos que o software está correto ou, eventualmente, bizantino. O software é chamado eventualmente de bizantino se, após ser reiniciado, pode-se confiar que o desempenho seja correto durante a execução de uma parte significativa da execução. o
a execução correta após a reinicialização é atribuída ao processo de teste e depuração que o software sofre ao ser lançado. Nosso framework não se destina a lidar com programas totalmente incorretos (bizantinos), como programas vazios (programas sem código).

A abordagem sugerida é mais eficiente do que a proposta em nosso trabalho anterior [4], pois agora assumimos que temos acesso ao programa. Em nosso trabalho anterior, tivemos que interceptar todas as ações de E / S para detectar um estado defeituoso - um recurso que implicava uma sobrecarga substancial. Neste trabalho, consideramos o caso em que o código é fornecido e podemos evitar essa sobrecarga monitorando
as variáveis, principalmente quando seus valores são alterados. Trabalho relatado. Existem ferramentas que monitoram a segurança aumentando os programas com código de monitoramento para problemas de segurança [13, 7] e fazendo algum tipo de recuperação, por exemplo, lançando uma exceção ou executando ações de recuperação predefinidas.

O bem conhecido e amplamente utilizado mecanismo de exceção [14] é uma técnica para lidar com entradas ilegais ou falhas subjacentes no sistema. Em [23], as transações são usadas como uma ferramenta para obter ações atômicas e usam exceções como uma ferramenta de recuperação no caso de uma transação falhar. No entanto, a prática mostra que as exceções não são práticas para programar um fluxo alternativo do programa em caso de falha [12].

O conceito de bloco de recuperação [21] sugeriu o uso de redundância de componentes (por exemplo, programação N) para lidar com falhas em partes críticas do sistema. O conceito de bloco de recuperação não suporta o monitoramento completo das propriedades de animação e não fornece garantias para a estabilidade de um mecanismo de monitoramento.

Existem várias linguagens conhecidas, Nurpl [8], ASM [15] e IO Automata [18], que fornecem uma linguagem formal para escrever especificações e estruturas de programas para traduzi-las gradual e manualmente em um programa totalmente verificado. Ainda assim, como o processo não é totalmente automatizado, não há garantia de que o código resultante esteja correto.

Escrever um programa como uma coleção de especificações SRC (Redução de Custos de Software) (especificação detalhada descrevendo completamente os autômatos do programa) e depois transformá-los automaticamente no código é sugerido em [22]. No entanto, o programa produzido pode ter os mesmos problemas que o mesmo programa gravado do zero por um programador devido a erros nas especificações detalhadas do SRC, que é, de fato, o programa.


O trabalho em [1, 17] tenta modelar uma camada de middleware para monitoramento e correção de software defeituoso arbitrário. As ações de correção são arbitrárias. Assim, o software original do sistema pode ser completamente ignorado ou seu estado privado pode ser alterado pela camada de correção. Portanto, o programador do componente que corrige as ações é, de fato, o programador do componente. Em nosso trabalho, nos limitamos apenas a ações de recuperação não invasivas, como reiniciar.

O resto do artigo está organizado da seguinte forma. A arquitetura do sistema aparece na Seção 2. Os detalhes de design e implementação de nosso framework são apresentados na Seção 3. A Seção 4 apresenta um caso de estudo que usa nossa estrutura. Neste caso de estudo, investigamos o problema clássico produtor-consumidor. As conclusões aparecem na Seção 5.

## A arquitetura do sistema

Um processador é uma entidade multitarefa que pode executar vários processos. Cada processo é modelado por uma máquina de estado que executa etapas atômicas de um programa que pode estar com defeito. Um passo atômico *a = (j, s, s0, io)* de um processo é uma transição do estado s para o estado s0 por um processo pj. A transição consiste em cálculos internos e em uma única interação de pj com outros processos por uma operação de entrada / saída (io). As capacidades de comunicação dos processos são definidas por um gráfico de comunicação direcionada G (V, E). Uma aresta (i, j) em G (V, E) denota a capacidade de um processo pj de receber informações de um processo pi por meio de mensagens ou memória compartilhada. A configuração do sistema consiste em um vetor hs1, s2,. . . , sn i, em que si é o estado de um processo pi no sistema e do conteúdo dos dispositivos de comunicação. O conteúdo dos dispositivos de comunicação é o conteúdo das filas de mensagens hm1,2, m1,3,. . . , mi, j,. . .i, onde mi, j é uma fila de mensagens enviadas por um processo pi para um processo pj ou a comunicação compartilhada registra hr1,2, r1,3,. . . ri, j,. . .i, em que ri, j é um registro compartilhado pelos processos pi e pj. Uma execução é uma sequência E = c1, a1, c2, a2,. . . de configurações ci e etapas atômicas ai para que ci + 1 seja alcançado a partir de ci pela execução de ai. Uma execução E é justa se todo processo executar uma etapa infinitamente com freqüência em E.

